<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>방치형 게임</title>
<style>
  :root{ --fg:#eee; --bg:#111; --muted:#a8a8a8; --card:#181818; --stroke:#3a3a3a; }
  *{ box-sizing:border-box }
  html,body{ height:100%; }
  body{
    margin:0; background:var(--bg); color:var(--fg);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans KR", sans-serif;
    display:flex; justify-content:center;
  }
  .wrap{ width:100%; min-height:100vh; display:flex; justify-content:center; }
  .screen{
    display:none; flex-direction:column; align-items:center;
    width:min(96vw, 720px);
    min-height:100vh; padding:5vh 4vw 12vh; gap:3vh; text-align:center;
  }
  #main{ display:flex; }
  .title{ font-size: clamp(22px, 6vw, 36px); margin:2vh 0; }

  .btn{
    background:#242424; color:var(--fg); border:2px solid var(--stroke);
    border-radius:14px; padding: 2.6vh 0; width:100%;
    font-size: clamp(16px, 5vw, 22px);
    transition:transform .08s ease, background .08s ease, border-color .08s ease;
    touch-action: manipulation; -webkit-tap-highlight-color: transparent;
  }
  .btn:active{ transform:scale(0.98); background:#333; }
  .btn:focus{ outline:none; }

  #story p{ font-size: clamp(16px, 5vw, 24px); line-height:1.6; max-width:92%; margin:.6vh 0; }
  .back{
    position:sticky; top:1.2vh; align-self:flex-start; background:none; border:none; color:var(--muted);
    font-size: clamp(14px, 4vw, 18px);
  }

  /* === 게임 화면 === */
  #game{ gap:2vh; padding-top:2vh; }
  .topbar{
    position:sticky; top:1vh; z-index:5;
    display:flex; justify-content:flex-end; align-items:center; gap:1.2vh;
    width:100%; font-size: clamp(14px, 4.2vw, 18px);
  }
  .badge{
    background:var(--card); border:1px solid var(--stroke); border-radius:999px;
    padding:.7vh 1.2vh; display:flex; gap:.6vh; align-items:center;
  }
  .auto{ color:var(--muted); }
  .flash{ animation: flash 420ms ease; }
  @keyframes flash{
    0%{ box-shadow:0 0 0 rgba(56,189,248,0); }
    30%{ box-shadow:0 0 18px rgba(56,189,248,.85); }
    100%{ box-shadow:0 0 0 rgba(56,189,248,0); }
  }

  .stage{
    width:100%; height:min(46vh, 400px);
    background:linear-gradient(180deg, #1a1a1a 0%, #141414 100%);
    border:1px solid var(--stroke); border-radius:18px; display:flex; justify-content:center; align-items:center;
    position:relative; margin-top:1vh;
  }
  canvas{ width:94%; height:90%; }

  .chips{ display:flex; gap:.8vh; flex-wrap:wrap; justify-content:center; width:100%; }
  .chip{ border:1px solid var(--stroke); border-radius:999px; padding:.6vh 1.1vh; font-size: clamp(12px, 3.6vw, 15px); color:var(--muted); }

  .controls{
    width:100%; display:grid; grid-template-columns:1fr 1fr; gap:1.2vh 1.2vh;
    margin-bottom:12vh;
  }
  .big{ grid-column:1 / -1; }
  .stat{
    display:flex; flex-direction:column; gap:.6vh; align-items:center;
    background:#202020; border:1px solid var(--stroke); border-radius:14px; padding:1.6vh 1.2vh;
    font-size: clamp(14px, 4.2vw, 18px); width:100%;
  }
  .stat .price{ font-size:.9em; color:var(--muted); }
  .stat .hint{ font-size:.85em; color:#8aa; }

  /* === 뽑기 화면 === */
  #gacha .stage{ height:min(40vh, 360px); }
  .gachaPrice{ color:var(--muted); font-size:clamp(13px,3.6vw,16px); }
  .gachaResult{ font-size:clamp(16px,4.6vw,20px); }
</style>
</head>
<body>
  <div class="wrap">
    <!-- 메인 -->
    <section id="main" class="screen">
      <h1 class="title">💀 방치형 생존기 💀</h1>
      <button id="startBtn" class="btn">시작</button>
      <button id="descBtn"  class="btn">설명</button>
      <button id="exitBtn"  class="btn">종료</button>
    </section>

    <!-- 설명 -->
    <section id="story" class="screen">
      <button id="backFromStory" class="back">← 이전</button>
      <p>지구는 멸망했다.</p>
      <p>남은 자들은 폐허 속에서 돈을 모은다.</p>
      <p>당신은 잊힌 기술을 복구하는 마지막 용사다.</p>
      <p>고철을 모으고 기계를 돌려 크레딧을 벌어라.</p>
      <p>자본만이 이 죽은 세상을 다시 움직인다.</p>
    </section>

    <!-- 게임 -->
    <section id="game" class="screen">
      <button id="backFromGame" class="back">← 메뉴</button>

      <div class="topbar">
        <div id="coinBadge" class="badge">💰 <span id="coinsText">0</span></div>
        <div class="badge auto">⏱️ 자동: <span id="autoText">0</span>/s</div>
      </div>

      <div class="stage">
        <canvas id="arena" width="680" height="400" aria-label="전투 캔버스"></canvas>
      </div>

      <div class="chips">
        <span class="chip">클릭(기본): <b id="clickVal">1</b></span>
        <span class="chip">뽑기배수: <b id="gachaMul">×1.00</b></span>
        <span class="chip">최종 클릭: <b id="clickEff">1</b></span>
        <span class="chip">치명타 확률: <b id="critPct">1.0%</b></span>
        <span class="chip">치명타 배수: <b id="critMul">×100</b></span>
        <span class="chip">민첩성(기본): <b id="agilityBase">0</b>/s</span>
        <span class="chip">동료 배수: <b id="allyMul">×1</b></span>
      </div>

      <div class="controls">
        <button id="btnEarn" class="btn big">돈 벌기 +<span id="earnAmt">1</span> | 💰 <span id="coinsInline">0</span></button>

        <!-- 동료 -->
        <div class="stat" id="boxAlly" style="grid-column:1 / -1;">
          <button id="btnAlly" class="btn" style="width:100%;">동료 고용</button>
          <div class="price">가격: <b id="allyCost">10</b></div>
          <div class="hint">동료 1명마다 민첩성 ×2 (가격×5)</div>
        </div>

        <div class="stat" id="boxAttack">
          <button id="btnAtk" class="btn" style="width:100%;">공격력 구매</button>
          <div class="price">가격: <b id="atkCost">10</b></div>
          <div class="hint">매 구매 클릭당 +1 (가격×1.3)</div>
        </div>

        <div class="stat" id="boxAgility">
          <button id="btnAgi" class="btn" style="width:100%;">민첩성 구매</button>
          <div class="price">가격: <b id="agiCost">10</b></div>
          <div class="hint">매 구매 기본 민첩성 +1/s (가격×1.3)</div>
        </div>

        <div class="stat" id="boxDefense" style="grid-column:1 / -1;">
          <button id="btnDef" class="btn" style="width:100%;">방어력 구매</button>
          <div class="price">가격: <b id="defCost">20</b></div>
          <div class="hint">매 구매 치확 +0.1% (기본 1%) (가격×1.3)</div>
        </div>

        <!-- 체력(크리티컬 배수 +1, 가격×1.5) -->
        <div class="stat" id="boxHP" style="grid-column:1 / -1;">
          <button id="btnHP" class="btn" style="width:100%;">체력 구매</button>
          <div class="price">가격: <b id="hpCost">30</b></div>
          <div class="hint">매 구매 치명타 배수 +1 (100→101…) | 가격×1.5</div>
        </div>

        <!-- 🔻 체력 아래: 살짝 작은 '뽑기' 버튼 -->
        <div class="stat" id="boxGacha" style="grid-column:1 / -1; padding:1.0vh 1.2vh;">
          <button id="btnGoGacha" class="btn" style="width:100%; padding:1.2vh 0; font-size:clamp(14px,4.4vw,18px);">뽑기 화면으로</button>
          <div class="hint">뽑기: 공격력에 배수 효과(중첩)</div>
        </div>
      </div>
    </section>

    <!-- 🎯 뽑기 화면 -->
    <section id="gacha" class="screen">
      <button id="backFromGacha" class="back">← 이전</button>
      <h2 class="title">🎲 뽑기</h2>

      <div class="stage">
        <canvas id="gachaCanvas" width="680" height="340" aria-label="뽑기 캔버스"></canvas>
      </div>

      <div class="gachaPrice">가격: <b id="gachaCostText">3,000</b> 코인</div>
      <button id="btnGacha" class="btn" style="max-width:420px;">뽑기 실행</button>
      <div id="gachaResult" class="gachaResult"></div>
    </section>
  </div>

<script>
  /* =========================
      상태(경제/전투/뽑기)
  ========================== */
  let coins = 0;
  let clickValue = 1;

  // 민첩성(기본)과 동료 배수
  let agilityLevel = 0;
  let agilityCost  = 10;
  let allyLevel    = 0;
  let allyCost     = 10;
  let allyMult     = 1;
  const effectiveAutoRate = () => agilityLevel * allyMult;

  // 공격력
  let attackLevel = 0;
  let attackCost  = 10;

  // 방어력(치명타 확률)
  let defenseLevel = 0;
  let defenseCost  = 20;
  let criticalChance = 1.0; // %

  // 체력(치명타 배수 +1 / 가격×1.5)
  let hpLevel = 0;
  let hpCost  = 30;
  const baseCritMult = 100;
  const currentCritMult = () => baseCritMult + hpLevel;

  // ▶ 뽑기(가챠)
  let gachaCost = 3000;
  let gachaMul  = 1.00; // 공격력 최종 배수(중첩)
  const GACHA_WEIGHTS = [
    { name:'빨강', color:'#ff4242', w:40, mult:1.2,  text:'공격력 ×1.2' },
    { name:'노랑', color:'#ffd24d', w:30, mult:1.25, text:'공격력 ×1.25' },
    { name:'핑크', color:'#ff77cc', w:3,  mult:2.0,  text:'공격력 ×2' },
    { name:'초록', color:'#4dff88', w:28, mult:1.3,  text:'공격력 ×1.3' },
  ];
  const GACHA_SUM = GACHA_WEIGHTS.reduce((s,x)=>s+x.w,0); // 101

  /* ===== 엘리먼트 ===== */
  const screens = {
    main:  document.getElementById('main'),
    story: document.getElementById('story'),
    game:  document.getElementById('game'),
    gacha: document.getElementById('gacha'),
  };
  const coinsText = document.getElementById('coinsText');
  const coinsInline = document.getElementById('coinsInline');
  const autoText  = document.getElementById('autoText');

  const clickValEl  = document.getElementById('clickVal');
  const clickEffEl  = document.getElementById('clickEff');
  const gachaMulEl  = document.getElementById('gachaMul');
  const critPctEl   = document.getElementById('critPct');
  const critMulEl   = document.getElementById('critMul');
  const agilityBaseEl = document.getElementById('agilityBase');
  const allyMulEl   = document.getElementById('allyMul');

  const btnEarn = document.getElementById('btnEarn');
  const earnAmt = document.getElementById('earnAmt');

  const btnAlly = document.getElementById('btnAlly'); const allyCostEl = document.getElementById('allyCost');
  const btnAtk  = document.getElementById('btnAtk');  const atkCostEl  = document.getElementById('atkCost');
  const btnAgi  = document.getElementById('btnAgi');  const agiCostEl  = document.getElementById('agiCost');
  const btnDef  = document.getElementById('btnDef');  const defCostEl  = document.getElementById('defCost');
  const btnHP   = document.getElementById('btnHP');   const hpCostEl   = document.getElementById('hpCost');

  const startBtn = document.getElementById('startBtn');
  const descBtn  = document.getElementById('descBtn');
  const exitBtn  = document.getElementById('exitBtn');
  const backFromStory = document.getElementById('backFromStory');
  const backFromGame  = document.getElementById('backFromGame');

  // 뽑기 화면
  const btnGoGacha = document.getElementById('btnGoGacha');
  const backFromGacha = document.getElementById('backFromGacha');
  const btnGacha = document.getElementById('btnGacha');
  const gachaCostText = document.getElementById('gachaCostText');
  const gachaResult = document.getElementById('gachaResult');

  /* ===== 화면 전환 ===== */
  function show(name){
    Object.values(screens).forEach(s=>s.style.display='none');
    screens[name].style.display='flex';
    window.scrollTo({top:0, behavior:'instant'});
  }
  show('main');
  startBtn.addEventListener('click', ()=> show('game'));
  descBtn.addEventListener('click', ()=> show('story'));
  backFromStory.addEventListener('click', ()=> show('main'));
  backFromGame.addEventListener('click', ()=> show('main'));
  exitBtn.addEventListener('click', ()=> { if(confirm('정말 종료하시겠습니까?')) window.close(); });

  btnGoGacha.addEventListener('click', ()=>{ show('gacha'); drawGacha(true); });
  backFromGacha.addEventListener('click', ()=> show('game'));

  /* ===== 유틸 ===== */
  const ceil13 = v => Math.ceil(v * 1.3);
  const ceil12 = v => Math.ceil(v * 1.2);
  const ceil15 = v => Math.ceil(v * 1.5);
  const ceil5  = v => Math.ceil(v * 5);
  const fmt = (n)=> Math.floor(n).toLocaleString('ko-KR', {maximumFractionDigits:0});
  function updateMultipliers(){ allyMult = 2 ** allyLevel; }

  function effectiveClickValue(){ return Math.max(1, Math.floor(clickValue * gachaMul)); }

  function updateUI(){
    const eff = effectiveClickValue();
    coinsText.textContent = fmt(coins);
    coinsInline.textContent = fmt(coins);
    autoText.textContent  = (effectiveAutoRate()).toString();

    clickValEl.textContent = clickValue.toString();
    gachaMulEl.textContent = '×' + gachaMul.toFixed(2);
    clickEffEl.textContent = eff.toString();

    critPctEl.textContent  = `${(Math.round(criticalChance*10)/10).toFixed(1)}%`;
    critMulEl.textContent  = `×${currentCritMult()}`;
    agilityBaseEl.textContent = agilityLevel.toString();
    allyMulEl.textContent  = `×${allyMult}`;

    earnAmt.textContent    = eff.toString();
    atkCostEl.textContent  = fmt(attackCost);
    agiCostEl.textContent  = fmt(agilityCost);
    defCostEl.textContent  = fmt(defenseCost);
    allyCostEl.textContent = fmt(allyCost);
    hpCostEl.textContent   = fmt(hpCost);

    gachaCostText.textContent = fmt(gachaCost);
  }

  /* ===== 모바일 연타 지원 ===== */
  function addTap(el, handler){
    let locked = false;
    el.addEventListener('pointerdown', (e)=>{
      e.preventDefault();
      if(locked) return;
      locked = true; handler(); setTimeout(()=> locked = false, 40);
    }, {passive:false});
    el.addEventListener('click', (e)=>{
      e.preventDefault();
      if(locked) return;
      locked = true; handler(); setTimeout(()=> locked = false, 40);
    }, {passive:false});
  }

  /* ===== 경제 로직 ===== */
  function earnOnce(){
    const eff = effectiveClickValue();
    const roll = Math.random()*100;
    let gain = eff;
    if(roll < criticalChance){
      gain = eff * currentCritMult();
      const coinBadge = document.getElementById('coinBadge');
      coinBadge?.classList.remove('flash'); void coinBadge?.offsetWidth; coinBadge?.classList.add('flash');
    }
    coins += gain;
    updateUI();
  }
  function buyAttack(){ if(coins<attackCost) return; coins-=attackCost; attackLevel++; clickValue++; attackCost=ceil13(attackCost); updateUI(); }
  function buyAgility(){ if(coins<agilityCost) return; coins-=agilityCost; agilityLevel++; agilityCost=ceil13(agilityCost); updateMultipliers(); updateUI(); }
  function buyAlly(){ if(coins<allyCost) return; coins-=allyCost; allyLevel++; allyCost=ceil5(allyCost); updateMultipliers(); updateUI(); }
  function buyDefense(){ if(coins<defenseCost) return; coins-=defenseCost; defenseLevel++; criticalChance=1.0+defenseLevel*0.1; defenseCost=ceil13(defenseCost); updateUI(); }
  function buyHP(){ if(coins<hpCost) return; coins-=hpCost; hpLevel++; hpCost=ceil15(hpCost); updateUI(); }

  setInterval(()=>{ const r=effectiveAutoRate(); if(r>0){ coins+=r; updateUI(); }}, 1000);

  addTap(document.getElementById('btnEarn'), earnOnce);
  addTap(document.getElementById('btnAtk'),  buyAttack);
  addTap(document.getElementById('btnAgi'),  buyAgility);
  addTap(document.getElementById('btnAlly'), buyAlly);
  addTap(document.getElementById('btnDef'),  buyDefense);
  addTap(document.getElementById('btnHP'),   buyHP);

  updateMultipliers(); updateUI();

  /* =========================
        전투(하단 단일 레인 + 충돌판정)
  ========================== */
  const canvas = document.getElementById('arena');
  const ctx = canvas.getContext('2d');
  const W = canvas.width, H = canvas.height;
  const GROUND = H - 46;
  const LANE_Y = GROUND - 2;

  // 영웅(하양+왕관)
  const HERO_X = W*0.25;
  const STOP_GAP = 46;
  const STOP_X = HERO_X + STOP_GAP;
  const hero = {
    x: HERO_X, y: LANE_Y, headR: 26,
    swordLen: 64,
    swinging: false, swingT: 0, swingDir: 1, crown: true
  };

  // 몬스터
  const TYPES = [
    {name:'슬라임', color:'#7ff57a', hp:[3,5], speed:[0.5,0.9], size:22, kind:'slime'},
    {name:'해골병사', color:'#cfcfcf', hp:[4,6], speed:[0.6,1.0], size:19, kind:'skeleton'},
    {name:'고블린', color:'#47d17a', hp:[5,7], speed:[0.8,1.2], size:18, kind:'goblin'},
    {name:'오크', color:'#1e7a3a', hp:[7,10], speed:[0.5,0.8], size:24, kind:'orc'},
    {name:'마족병사', color:'#e85',  hp:[10,14], speed:[0.6,0.9], size:22, kind:'fiend'},
  ];
  const BOSS = {name:'보스', color:'#ff3b3b', hp:[40,60], speed:[0.4,0.6], size:36, kind:'boss', isBoss:true};

  const monsters = []; // {x,y,hp,max,speed,size,type,isBoss,dead,ttl,hitInSwing}
  const particles = [];
  const slashes = [];
  const coinFX   = [];

  function randRange([a,b]){ return a + Math.random()*(b-a); }

  function spawnMonster(isBoss=false){
    const T = isBoss ? BOSS : TYPES[Math.floor(Math.random()*TYPES.length)];
    const hp = Math.round(randRange(T.hp));
    monsters.push({
      x: W + 40, y: LANE_Y,
      hp, max:hp,
      speed: randRange(T.speed), size: T.size, type:T, isBoss: !!T.isBoss,
      dead:false, ttl:0, hitInSwing:false
    });
  }
  setInterval(()=> spawnMonster(false), 2000);
  setInterval(()=> spawnMonster(true), 30000);

  /* ==== 스윙: 1.1초마다 시작 ==== */
  setInterval(()=>{
    hero.swinging = true;
    hero.swingT = 0;
    hero.swingDir *= -1;
    monsters.forEach(m=> m.hitInSwing = false);
  }, 1100);

  /* ==== 충돌: 선분-원 거리 ==== */
  function distPointToSeg(px,py, x1,y1, x2,y2){
    const vx = x2-x1, vy=y2-y1, wx=px-x1, wy=py-y1;
    const c1 = vx*wx + vy*wy;
    if(c1 <= 0) return Math.hypot(px-x1, py-y1);
    const c2 = vx*vx + vy*vy;
    if(c2 <= c1) return Math.hypot(px-x2, py-y2);
    const t = c1 / c2;
    const projx = x1 + t*vx, projy = y1 + t*vy;
    return Math.hypot(px-projx, py-projy);
  }

  /* ==== 타격 처리 ==== */
  function hitMonster(m){
    m.hp -= 2;
    const sx = hero.x + 26, sy = hero.y - 16;
    const ex = sx + (hero.swingDir>0?1:-1) * hero.swordLen;
    const ey = sy - (hero.swingDir>0?1:-1) * 10;
    slashes.push({x1:sx,y1:sy,x2:ex,y2:ey,ttl:160});
    for(let i=0;i<6;i++){
      particles.push({x:m.x, y:m.y-24, vx:(Math.random()-0.5)*2, vy:-Math.random()*2-0.5, ttl:500});
    }
    if(m.hp<=0){
      m.dead = true; m.ttl = 400;
      const n = m.isBoss ? 6 : 3;
      for(let i=0;i<n;i++){
        coinFX.push({x:m.x, y:m.y-30, vx:(Math.random()-0.5)*1.6, vy:-Math.random()*1.8-0.6, ttl:2000});
      }
    }
  }

  function drawGround(){
    ctx.strokeStyle = '#2e2e2e'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(40, GROUND); ctx.lineTo(W-40, GROUND); ctx.stroke();
    ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.setLineDash([6,6]);
    ctx.beginPath(); ctx.moveTo(STOP_X, GROUND-60); ctx.lineTo(STOP_X, GROUND); ctx.stroke();
    ctx.setLineDash([]);
  }

  function drawHero(){
    const x = hero.x, y = hero.y;
    const barY = y - 70;
    ctx.fillStyle='rgba(255,255,255,0.12)';
    ctx.fillRect(20, barY, 110, 20);
    ctx.beginPath(); ctx.moveTo(130, barY); ctx.lineTo(148, barY+10); ctx.lineTo(130, barY+20); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#fff'; ctx.font='bold 14px system-ui'; ctx.textBaseline='middle'; ctx.fillText('용사', 30, barY+10);

    ctx.strokeStyle = '#fff'; ctx.lineWidth=6; ctx.lineCap='round';
    ctx.beginPath(); ctx.arc(x, y-70, hero.headR, 0, Math.PI*2); ctx.stroke();
    ctx.fillStyle='#ffd700';
    const cy = y-70-hero.headR-2;
    ctx.beginPath();
    ctx.moveTo(x-18, cy+8); ctx.lineTo(x-10, cy-6); ctx.lineTo(x, cy+8); ctx.lineTo(x+10, cy-6); ctx.lineTo(x+18, cy+8); ctx.closePath(); ctx.fill();
    ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x-10, cy-6, 2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+10, cy-6, 2, 0, Math.PI*2); ctx.fill();

    ctx.beginPath(); ctx.moveTo(x, y-50); ctx.lineTo(x, y-6); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-36); ctx.lineTo(x-30, y-8); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-6); ctx.lineTo(x-24, y+28); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x, y-6); ctx.lineTo(x+24, y+28); ctx.stroke();

    const baseAngle = hero.swingDir>0 ? (-20*Math.PI/180) : (200*Math.PI/180);
    const sweep = hero.swingDir>0 ? (120*Math.PI/180) : (-120*Math.PI/180);
    const t = Math.min(1, Math.max(0, hero.swingT));
    const ang = baseAngle + sweep * t;
    const armLen = 26;
    const ax = x + Math.cos(ang)*armLen;
    const ay = y - 36 + Math.sin(ang)*armLen;
    ctx.beginPath(); ctx.moveTo(x, y-36); ctx.lineTo(ax, ay); ctx.stroke();
    const sx = ax, sy = ay;
    const ex = sx + Math.cos(ang)*hero.swordLen;
    const ey = sy + Math.sin(ang)*hero.swordLen;
    ctx.strokeStyle='#ddd'; ctx.lineWidth=5; ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey); ctx.stroke();
    ctx.strokeStyle='#aaa'; ctx.lineWidth=6; ctx.beginPath(); ctx.moveTo(sx-6, sy+2); ctx.lineTo(sx+6, sy-2); ctx.stroke();

    if(hero.swinging && t>0.15 && t<0.95){
      for(const m of monsters){
        if(m.dead) continue;
        const dist = distPointToSeg(m.x, m.y-28, sx, sy, ex, ey);
        if(!m.hitInSwing && dist <= m.size*0.85){
          m.hitInSwing = true;
          hitMonster(m);
        }
      }
      slashes.push({x1:sx,y1:sy,x2:ex,y2:ey,ttl:140});
    }
  }

  function drawSlash(s){
    const life = Math.max(0, s.ttl/140);
    ctx.save();
    ctx.globalAlpha = 0.35 * life;
    ctx.fillStyle='#ffffff';
    const nx = s.x2 - s.x1, ny = s.y2 - s.y1;
    const L = Math.hypot(nx,ny) || 1;
    const px = -ny/L*10, py = nx/L*10;
    ctx.beginPath(); ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2+px, s.y2+py); ctx.lineTo(s.x2-px, s.y2-py); ctx.closePath(); ctx.fill();
    ctx.globalAlpha = 0.7 * life;
    ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(s.x1, s.y1); ctx.lineTo(s.x2, s.y2); ctx.stroke();
    ctx.restore();
  }

  function drawMonster(m){
    const x = m.x, y = m.y;
    switch(m.type.kind){
      case 'slime':
        ctx.fillStyle = '#214d21'; ctx.beginPath(); ctx.ellipse(x, y-6, m.size*1.2, m.size*0.7, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = m.type.color; ctx.beginPath(); ctx.ellipse(x, y-8, m.size*1.2, m.size*0.7, 0, 0, Math.PI); ctx.fill();
        break;
      case 'skeleton':
        ctx.fillStyle='#cfcfcf'; ctx.beginPath(); ctx.arc(x, y-34, m.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#333'; ctx.fillRect(x-m.size*0.6, y-36, m.size*0.5, m.size*0.4); ctx.fillRect(x+m.size*0.1, y-36, m.size*0.5, m.size*0.4);
        ctx.fillStyle='#cfcfcf'; ctx.fillRect(x-4, y-24, 8, 26); ctx.fillRect(x-12, y-14, 24, 5);
        break;
      case 'goblin':
        ctx.fillStyle='#47d17a'; ctx.beginPath(); ctx.arc(x, y-38, m.size, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x-m.size, y-40); ctx.lineTo(x-m.size-8, y-46); ctx.lineTo(x-m.size+2, y-32); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+m.size, y-40); ctx.lineTo(x+m.size+8, y-46); ctx.lineTo(x+m.size-2, y-32); ctx.closePath(); ctx.fill();
        ctx.fillRect(x-6, y-28, 12, 22);
        break;
      case 'orc':
        ctx.fillStyle='#1e7a3a'; ctx.fillRect(x-10, y-30, 20, 28);
        ctx.beginPath(); ctx.arc(x, y-38, m.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#bde7b7'; ctx.fillRect(x-6, y-34, 12, 4);
        break;
      case 'fiend':
        ctx.fillStyle='#e85'; ctx.beginPath(); ctx.arc(x, y-40, m.size, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#f6b'; ctx.beginPath(); ctx.moveTo(x-m.size*0.6, y-48); ctx.lineTo(x-m.size*0.2, y-54); ctx.lineTo(x-m.size*0.1, y-44); ctx.fill();
        ctx.beginPath(); ctx.moveTo(x+m.size*0.6, y-48); ctx.lineTo(x+m.size*0.2, y-54); ctx.lineTo(x+m.size*0.1, y-44); ctx.fill();
        ctx.fillStyle='#e85'; ctx.fillRect(x-7, y-32, 14, 24);
        break;
    }
    const w = m.isBoss ? 88 : 48;
    const ratio = Math.max(0, m.hp / m.max);
    ctx.fillStyle = '#333'; ctx.fillRect(x - w/2, y-56, w, 6);
    ctx.fillStyle = m.isBoss ? '#f33' : '#e85'; ctx.fillRect(x - w/2, y-56, w*ratio, 6);
  }

  function drawParticles(){
    particles.forEach(p=>{
      ctx.fillStyle='rgba(255,200,160,0.9)';
      ctx.fillRect(p.x, p.y, 2, 2);
    });
    slashes.forEach(drawSlash);
    coinFX.forEach(c=>{
      ctx.fillStyle='gold';
      ctx.beginPath(); ctx.arc(c.x, c.y, 4, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(255,215,0,0.6)'; ctx.lineWidth=1;
      ctx.beginPath(); ctx.arc(c.x, c.y, 7, 0, Math.PI*2); ctx.stroke();
    });
  }

  function updateMonsters(dt){
    monsters.forEach(m=>{
      if(!m.dead){
        if(m.x > STOP_X) m.x -= m.speed * dt * 0.06;
        if(m.x < STOP_X) m.x = STOP_X;
      }else{
        m.ttl -= dt;
      }
    });
    const MIN_GAP = 70;
    monsters.sort((a,b)=>a.x-b.x);
    for(let i=1;i<monsters.length;i++){
      const back = monsters[i], front = monsters[i-1];
      if(front.dead) continue;
      if(back.x - front.x < MIN_GAP){
        back.x = front.x + MIN_GAP;
      }
    }
    for(let i=monsters.length-1;i>=0;i--){
      if(monsters[i].dead && monsters[i].ttl<=0) monsters.splice(i,1);
    }
  }

  function updateParticles(dt){
    particles.forEach(p=>{ p.x+=p.vx*dt*0.06; p.y+=p.vy*dt*0.06; p.ttl-=dt; });
    for(let i=particles.length-1;i>=0;i--){ if(particles[i].ttl<=0) particles.splice(i,1); }
    slashes.forEach(s=> s.ttl -= dt);
    for(let i=slashes.length-1;i>=0;i--){ if(slashes[i].ttl<=0) slashes.splice(i,1); }
    coinFX.forEach(c=>{ c.x+=c.vx*dt*0.06; c.y+=c.vy*dt*0.06; c.vy+=0.002*dt; c.ttl-=dt; });
    for(let i=coinFX.length-1;i>=0;i--){ if(coinFX[i].ttl<=0) coinFX.splice(i,1); }
  }

  let last = performance.now();
  function loop(t){
    const dt = t - last; last = t;
    ctx.clearRect(0,0,W,H);
    drawGround();

    if(hero.swinging){
      hero.swingT += dt / 220;
      if(hero.swingT >= 1){ hero.swingT = 1; hero.swinging = false; }
    }

    updateMonsters(dt);
    updateParticles(dt);
    monsters.forEach(drawMonster);
    drawParticles();
    drawHero();

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  /* =========================
      🎲 뽑기 화면(계란 → 구슬)
  ========================== */
  const gCanvas = document.getElementById('gachaCanvas');
  const gCtx = gCanvas.getContext('2d');
  const gW = gCanvas.width, gH = gCanvas.height;

  let eggState = 'idle'; // idle | shake | crack | reveal
  let eggT = 0;
  let orb = null; // {color}

  function drawEggScene(){
    gCtx.clearRect(0,0,gW,gH);
    // 배경
    gCtx.fillStyle = '#141414';
    gCtx.fillRect(0,0,gW,gH);

    // 계란 위치
    const cx = gW/2, cy = 120;

    // 계란(핑크)
    if(eggState!=='reveal'){
      const shakeX = (eggState==='shake') ? Math.sin(eggT*20)*4 : 0;
      gCtx.save();
      gCtx.translate(shakeX,0);
      // 그림자
      gCtx.fillStyle='rgba(0,0,0,0.25)';
      gCtx.beginPath(); gCtx.ellipse(cx, cy+70, 46, 12, 0, 0, Math.PI*2); gCtx.fill();
      // 껍데기
      const crack = Math.min(1, Math.max(0, (eggState==='crack') ? eggT/700 : 0));
      gCtx.fillStyle='#ff99cc';
      gCtx.beginPath(); gCtx.ellipse(cx, cy, 50, 70, 0, 0, Math.PI*2); gCtx.fill();
      // 금
      if(crack>0){
        gCtx.strokeStyle='#fff'; gCtx.lineWidth=2;
        gCtx.beginPath();
        gCtx.moveTo(cx, cy-50);
        gCtx.lineTo(cx-8, cy-20);
        gCtx.lineTo(cx+10, cy+10);
        gCtx.lineTo(cx-6, cy+40);
        gCtx.stroke();
      }
      gCtx.restore();
    }

    // 구슬
    if(orb){
      gCtx.fillStyle = orb.color;
      gCtx.beginPath(); gCtx.arc(gW/2, 240, 30, 0, Math.PI*2); gCtx.fill();
      gCtx.fillStyle='rgba(255,255,255,0.35)';
      gCtx.beginPath(); gCtx.arc(gW/2-10, 230, 10, 0, Math.PI*2); gCtx.fill();
    }
  }

  let gLast = performance.now();
  function gLoop(t){
    const dt = t - gLast; gLast = t;
    if(eggState==='shake'){ eggT += dt; if(eggT>500){ eggState='crack'; eggT=0; } }
    else if(eggState==='crack'){ eggT += dt; if(eggT>800){ eggState='reveal'; eggT=0; } }
    drawEggScene();
    requestAnimationFrame(gLoop);
  }
  requestAnimationFrame(gLoop);

  function drawGacha(reset=false){
    if(reset){ eggState='idle'; eggT=0; orb=null; }
    drawEggScene();
  }

  function rollGacha(){
    // 코인 차감
    if(coins < gachaCost){ gachaResult.textContent = '코인이 부족합니다!'; return; }
    coins -= gachaCost;
    gachaCost = ceil12(gachaCost);

    // 추첨 (가중치 합 101 기준)
    let r = Math.random() * GACHA_SUM;
    let pick = GACHA_WEIGHTS[GACHA_WEIGHTS.length-1];
    for(const item of GACHA_WEIGHTS){
      if(r < item.w){ pick = item; break; }
      r -= item.w;
    }

    // 애니메이션 → 결과 표시
    gachaResult.textContent = '뽑는 중…';
    eggState='shake'; eggT=0; orb=null;

    setTimeout(()=>{
      eggState='crack'; eggT=0;
      setTimeout(()=>{
        eggState='reveal'; orb={color:pick.color};
        // 배수 적용(중첩)
        gachaMul *= pick.mult;
        gachaResult.textContent = `${pick.name} 구슬! (${pick.text})`;
        updateUI();
      }, 820);
    }, 520);

    updateUI();
  }

  addTap(btnGacha, rollGacha);

</script>
</body>
</html>